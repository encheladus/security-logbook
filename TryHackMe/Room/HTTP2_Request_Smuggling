# HTTP/2 Request Smuggling — TryHackMe - Web Application Pentesting  
**Date:** 2025-11-09  
**Type:** TryHackMe / Classroom  
**Scope:** Lab / Authorized only

---

## 1) Context
Short summary (1–3 lines): Study of HTTP/2-specific request smuggling vectors where protocol translation (HTTP/2 ↔ HTTP/1.1) or h2c upgrades reintroduce framing ambiguities. Objective: map H2→H1.1 translation risks (H2.CL, H2.TE, CRLF-in-headers, h2c tunnelling), safely fingerprint translation behavior, and learn defensive measures.

## 2) Initial hypothesis
What you expected before starting:  
HTTP/2's binary framing should eliminate classic HTTP/1.1 smuggling, but real-world deployments that downgrade H2→H1.1 (or forward h2c) may re-open smuggling vectors. By probing translation boundaries and header handling we can detect desync/tunnelling conditions and assess impact (ACL bypass, cache poisoning, header leakage).

## 3) Tools used
Short list:  
- curl (with HTTP/2 support)  
- Burp Suite (raw request control & Repeater)  
- Custom PoC clients to craft H2 frames / h2c Upgrade requests  
- Server/proxy log correlation (edge vs origin)  
- Controlled test endpoints (echo, healthz)  

*(No credentials, destructive exploits, or sensitive payloads included.)*

## 4) Approach (high level)
- **Map request path and versions:** identify per-hop protocols (client→CDN/WAF→LB→backend) and ALPN negotiation (h2/http/1.1).  
- **Fingerprint translation:** send H2 requests containing `content-length`, `transfer-encoding`, and control chars in header values to observe how the proxy translates into H1.1.  
- **Probe for CRLF injection:** test whether H2 header values containing `\r\n` get turned into extra H1.1 header lines.  
- **Distinguish tunnel vs cross-connection desync:** check whether backend connections are per-client (tunnelling) or shared (classic desync).  
- **Use benign canaries:** inject harmless echo/canary requests to safely confirm desync or tunnel behavior (no state changes).  
- **Assess impact surface:** if desync/tunnel exists, explore header leakage, ACL bypass potential, and low-risk cache influence (only in scoped lab).

## 5) Results / Evidence (sanitized)
What I observed:  
- **Translation boundary is the key**: when the edge accepted H2 and the backend used H1.1, header forwarding behavior determined whether a desync was possible.  
- **H2.CL and H2.TE probes** showed differences in how the edge normalized/forwarded `content-length` and `transfer-encoding`. In some lab configs the edge forwarded headers verbatim; in others it sanitized them.  
- **CRLF-in-header** tests were rejected by hardened edges but accepted/translated by misconfigured ones — a successful translation of control chars into H1.1 line breaks produces header/request injection risk.  
- **h2c upgrade handling**: when the proxy forwarded `Upgrade: h2c` to the backend and then tunneled the upgraded connection, the backend received raw H2 frames the proxy didn’t inspect (h2c tunnelling). This created a channel to bypass edge checks in the lab environment used for training.  
- **Tunnelling vs cross-client desync**: lab setups with per-client pinned backend connections produced tunnelling behaviors (impact confined to the attacker’s backend connection — still useful for cache poisoning and header leak tests). Shared backend connections allow classic cross-client smuggling, which is higher impact.  
- **Sanitized proof (non-destructive):** canary `GET /echo?canary=h2test` reflected by backend despite no matching edge log entry; indicates translation-induced extra request was processed downstream.

## 6) Recommended remediation
Generic technical measures:  
- **Avoid silent H2→H1.1 downgrades**: prefer end-to-end H2 or H1.1; if translation is required, perform strict normalization at ingress.  
- **Canonicalize / sanitize headers on ingress**: strip conflicting framing headers (do not forward `Transfer-Encoding` from H2), reject or sanitize header values containing control chars (`\r`, `\n`).  
- **Reject ambiguous requests**: return 400 on mixed CL/TE combos or duplicate/unknown TE tokens.  
- **Disable/limit h2c on public edges**: require TLS (h2) or handle upgrades at the proxy while maintaining inspection/enforcement.  
- **Align parser behavior**: use RFC-compliant parsers across edge and origin, keep software patched, and ensure consistent header handling.  
- **Harden caches**: avoid caching responses keyed on attacker-controlled inputs; ensure caches respect authentication and vary keys prudently.  
- **Logging & monitoring**: correlate edge and backend logs, alert on `101 Switching Protocols`, long-lived tunnels, mixed TE/CL combos, and CRLF-like header anomalies.

## 7) Lessons learned
- **HTTP/2 reduces internal ambiguity** but **translation boundaries** (H2→H1.1, h2c upgrade) reintroduce smuggling surfaces.  
- **H2.CL / H2.TE / CRLF-in-header / h2c** are distinct practical classes to test when H2 is present.  
- **Tunnelling** (per-client backend connection) still enables powerful attacks (header leak, cache poisoning, ACL bypass relative to that connection).  
- **Testing must be cautious**: use benign canaries, short TTLs for cache tests, and always operate within scope.

---

## 8) Links / Resources
- RFC 7540 (HTTP/2) and RFC 7230 (HTTP/1.1 framing) – for protocol framing reference  
- Vendor docs: NGINX / HAProxy / Envoy hardening guides for H2→H1 translation  
- PortSwigger research and academic papers on H2 smuggling / h2c tunnelling (recommended reading for deeper technique examples)

---