# Enumeration & Bruteforce — TryHackMe - Web Application Pentesting
**Date:** 2025-10-17  
**Type:** TryHackMe / Classroom  
**Scope:** Lab / Authorized only

---

## 1) Context
Short summary (1–3 lines):  
This classroom module covers **authentication enumeration**: systematic probing of login, reset and session flows to discover user enumeration, weak password policies, reset abuse and token flaws. The learning objective is to detect realistic attack paths (spray, stuffing, reset abuse), measure their impact, and produce clear, actionable remediation for defenders.

## 2) Initial hypothesis
What I expected before starting:  
The app will likely leak identity information through subtle differences in responses (login vs reset vs registration). Passive OSINT combined with a few safe, differential probes will reveal valid usernames and password-policy details enabling low-noise follow-ups (password-spray, targeted phishing, reset-abuse).

## 3) Tools used
Short list (no options/credentials):
- `curl`, Burp Suite (intercept / replay)
- Python `requests` (automation prototype)
- Gobuster / ffuf (endpoint discovery)
- waybackurls / gau (OSINT)
- `grep`, `jq`, `awk` for response analysis
- Timing measurement (simple `time` or script-based)

## 4) Approach (high level)
- Passive collection first: harvest usernames from site content, robots, Wayback, public repos and social profiles.
- Fingerprint the auth endpoints by sending single controlled probes (known-invalid vs known-valid) and recording status, headers, body length, JSON fields, redirects and timing.
- Build a differential oracle from the smallest reliable signal (message text, JSON `status`, `Content-Length`, `Set-Cookie`, or response time).
- Automate gently: low-rate scripted checks with jitter, CSRF handling, and retries; prefer password-spray patterns over per-account brute force.
- For reset/token checks, analyze token format & entropy; test expiry/single-use in a lab environment only.

## 5) Results / Evidence (sanitized)
- Found oracle signals (examples):
  - Message text differences: `"Email does not exist"` vs `"Bad credentials"`.
  - HTTP differences: status codes and response lengths varied between non-existent and valid users.
  - Timing delta: valid-user flows took measurably longer (hash check path).
  - Reset endpoints sometimes leaked existence via different messages or side-effects (email send).
- Practical issues encountered:
  - Subtle signals are easy to miss (length/timing differences).
  - CSRF / dynamic tokens complicate automation — script must fetch token first.
  - Aggressive automation triggers lockouts/WAFs; must throttle.
- Example reproducible evidence to include in a report:
  - Endpoint URL & method, sanitized request/response pairs, exact oracle string (case-sensitive), headers and timing, and number/percent of enumerated accounts.

## 6) Recommended remediation
- Use **generic responses** on login/reset (e.g., “If this account exists, we have sent an email”), avoid revealing “user not found” vs “wrong password”.
- Rate-limit auth endpoints, implement progressive delays and lockdown thresholds; consider CAPTCHA for suspicious patterns.
- Add multi-factor authentication (MFA) for high-value accounts and management consoles.
- Harden reset flows: tokens must be cryptographically random, single-use, short-lived, and verification endpoints must rate-limit and use generic messages.
- Ensure APIs return the same machine-readable response shape for valid/invalid attempts and avoid distinct status codes that leak information.
- Monitor & alert on enumeration patterns (repeated invalid login attempts, many reset requests for many users).
- For Basic auth endpoints: require HTTPS, disable default credentials, add rate-limiting, and migrate to stronger auth if possible.

## 7) Lessons learned
- Passive OSINT often yields more value and less noise than blind brute force—collect user lists first.
- The effective “oracle” can be extremely subtle: exact message text, cookie behavior, response length, redirect presence, or timing differences.
- Always capture exact request/response pairs (sanitised) for reproducibility and remediation.
- Password-spraying (few common passwords across many accounts) is both safer and often more effective than focused brute force.
- Test token robustness and reset behavior in a lab environment — don’t brute-force production verification endpoints.

---

## 8) Links / Resources
- TryHackMe — Web Application Pentesting (Authentication enumeration module)
- OWASP Testing Guide — Authentication & Session Management
- waybackurls / gau — historical URL harvesting tools
- SecLists — username/password wordlists
- References: articles on password-spraying, reset-token best practices, and Basic Auth guidance

---