# Prototype Pollution — TryHackMe - Web Application Pentesting  
**Date:** 2025-11-02  
**Type:** TryHackMe / Classroom  
**Scope:** Lab / Authorized only

---

## 1) Context
Short summary (1–3 lines): this lab explores **prototype pollution** in JavaScript — how object prototypes work, why mutating `__proto__`/`constructor`/`prototype` is dangerous, how unsafe deep merges and path-setters create pollution sinks, and how pollution can be chained to XSS, privilege escalation, or DoS.

## 2) Initial hypothesis
If the application accepts user-controlled object paths or performs deep merges without sanitizing keys, it may be possible to inject `__proto__`, `constructor` or `prototype` entries and thereby **pollute the prototype**, affecting app-wide behavior.

## 3) Tools used
Static analysers (NodeJsScan / Protoscan), fuzzers (PPFuzz / custom payloads), Burp Suite (proxy/repeater), cURL, local listener for OOB checks, manual inspection of source and deps (package.json).  
— **do not** include options, credentials, or sensitive scripts.

## 4) Approach (high level)
- Review source & dependencies for risky patterns: `_.merge`, `_.set`, `Object.assign`, custom deep-merge functions, dynamic property assignment.
- Static-scan candidate files; triage hotspots.
- Dynamically fuzz APIs that accept nested JSON or path strings with prototype keys (`__proto__`, `constructor`, `prototype`) and path forms usable by `_.set`.
- Verify pollution by checking `Object.prototype` or observable behavior (e.g., `({}).isAdmin === true`).
- Attempt practical chains: privilege bypass (flip flags), render path to XSS, introduce heavy getters/functions to trigger DoS.

## 5) Results / Evidence (sanitized)
What I observed:
- Endpoints accepting nested JSON / path strings allowed injection of `__proto__` or `constructor.prototype` in several test cases.
- After merging payloads like `{ "__proto__": { "isAdmin": true } }`, checks relying on `user.isAdmin` allowed elevated access in the test environment.
- Render flows that later used polluted properties produced unsafe HTML in one scenario (demonstrated stored XSS in lab conditions).
- Injecting malicious prototypes (heavy arrays/getters) led to increased memory/CPU usage and worker instability in controlled tests.
- Sanitized proof: final state — `Object.prototype.isAdmin` changed by attacker-controlled input, leading to authorization bypass on a protected endpoint.

## 6) Recommended remediation
Generic technical measures:
- **Reject prototype keys:** disallow `__proto__`, `prototype`, `constructor` in user-supplied keys at the input boundary.
- **Use schema validation:** validate incoming JSON against strict schemas (Joi, Zod) and only accept expected fields.
- **Avoid blind deep merges:** prefer explicit allowlists and map user inputs to known-safe fields; avoid `_.merge`/`_.set` on untrusted data.
- **Use prototype-free maps for dynamic keys:** `Object.create(null)` for untrusted key-value stores (no inherited props).
- **Immutable / frozen configs:** use `Object.freeze()` for shared configs where feasible.
- **Harden dependencies:** keep libraries (Lodash, deepmerge, etc.) up to date and monitor CVEs.
- **Runtime protection:** limit resource usage, apply timeouts, monitor for anomalous CPU/memory, and log suspicious merges.
- **Client-side safeguards & CSP:** enforce proper escaping; configure CSP to reduce XSS impact if pollution reaches rendering paths.

## 7) Lessons learned
- Prototype pollution is **an enabler** — often not a standalone RCE, but it can flip flags, bypass auth, or make XSS/DoS practical.
- Dangerous patterns: dynamic property assignment (`obj[a][b] = v` with attacker-controlled `a`/`b`) and blind deep merges (`_.merge`, recursive `for..in` loops without `hasOwnProperty`).
- Detection needs both static analysis (find sinks) and dynamic fuzzing (confirm practical exploitability).
- Practical verification: check `Object.prototype` and observe how app logic behaves with the polluted properties.
- Mitigations are straightforward and preventive: input filtering, schema validation, prototype-free maps, and dependency hygiene.

## 8) Links / Resources
- NodeJsScan — static analysis for Node.js  
- Protoscan / PPFuzz — prototype pollution scanners & fuzzers  
- Lodash docs & CVE advisories (check older `_.merge` / `_.set` behavior)  
- OWASP notes on object injection / prototype pollution  
- Notion / detailed write-up (public): *(add link here if applicable)*

---